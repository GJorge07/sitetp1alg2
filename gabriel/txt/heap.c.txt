/*Implementação do Tipo Abstrato de Dados Heap*/

#include <stdio.h>
#include <stdlib.h> //precisa?? !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#include <string.h>
#include "heap.h"

//Verificar se vai ser esses tamanhos mesmo!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//Usar memset para inicializar strings?? ou char nome[50] = ""?? !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

struct paciente
{
	char nome[TAM_NOME];
	int prioridade;
};

struct heap
{
	struct paciente fila[CAPACIDADE + 1];
	int tam;
};

void Troca(struct paciente *a, struct paciente *b)
{
	struct paciente aux = *a;
	*a = *b;
	*b = aux;
}


int HeapVazio(Heap *h)
{
	if (h->tam == 0)
		return 1;
	return 0;
}


int TamHeap(Heap *h)
{
	if (h == NULL)
		return -1;

	return h->tam;
}


Heap *InicHeap()
{
	struct heap *h;
	if (!(h = malloc(sizeof(struct heap))))
		return NULL;

	h->tam = 0;

	return h;
}

int InsereHeap(Heap *h, int prioridade, const char *nome)
{
	int i;

	/*--------Verificações iniciais-------*/
	if (h == NULL || h->tam >= CAPACIDADE)
		return 0;

	/*Verifica se nome já existe na fila*/
	for (i = 1; i <= h->tam; i++)
		if (strcmp(h->fila[i].nome, nome) == 0)
			return -1;

	if (strlen(nome) >= TAM_NOME || strlen(nome) == 0)
		return -1;
	/*------------------------------------*/
	
	h->tam++;

	i = h->tam;

	h->fila[i].prioridade = prioridade;
	strcpy(h->fila[i].nome, nome);
	
	while (i > 1 && h->fila[i/2].prioridade < h->fila[i].prioridade) 
	{
		Troca(&(h->fila[i/2]), &(h->fila[i]));
		i = i/2;
	}

	return 1;
}


void RemoveHeap(Heap *h, char *NomeRemovido)
{
	if (h == NULL)
	{
		strcpy(NomeRemovido, "Fila Nula!");
		return;
	}

	if (HeapVazio(h))
	{
		strcpy(NomeRemovido, "Fila Vazia!");
		return;
	}

	strcpy(NomeRemovido, h->fila[1].nome);

	h->fila[1] = h->fila[h->tam]; /*Coloca o último paciente no início*/
	
	h->tam--;
	
	SacodeHeap(h, h->tam); /*Acerta a posição do primeiro paciente*/
}


//Reportar número de comparações e Trocas!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
int Heapfy(Heap *h)
{
	int i, guarda_tam;

	if (h == NULL)
		return -1;

	if (HeapVazio(h))
		return 0;

	guarda_tam = h->tam;
	
	h->tam = 1;

	/*laço que seleciona o da vez que será inserido*/
	for (i = 2; i <= guarda_tam; i++) 
		InsereHeap(h, h->fila[i].prioridade, h->fila[i].nome);

	return 1;
}


int ChecaHeap(Heap *h)
{
	int i;

	if (h == NULL || HeapVazio(h))
		return -1;

	for (i = h->tam; i > 1; i--)
		if (h->fila[i/2].prioridade < h->fila[i].prioridade) //menor ou menor e igual??
			return 0;
	
	return 1;
}


void ImprimeHeap(Heap *h)
{
	int i;

	printf("\nImprimindo fila de pacientes...\n\n");
	
	if (h == NULL)
	{
		printf("Fila Nula!\n\n");
		return;
	}

	if (HeapVazio(h))
	{
		printf("Fila vazia!\n\n");
		return;
	}

	printf("Fila de espera:\n\n");

	for (i = 1; i <= h->tam-1; i++)
		printf("(%d - %s)\n", h->fila[i].prioridade, h->fila[i].nome);
	printf("(%d - %s)\n\n", h->fila[h->tam].prioridade, h->fila[h->tam].nome);
}

//Reportar número de comparações e Trocas!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
int HeapSort(Heap *h)
{
	int i, status;
	
	status = Heapfy(h);

	if (status == -1) /*Fila nula*/
		return -1;

	if (status == 0) /*Fila vazia*/
		return 0;
	
	for (i = h->tam; i > 1; i--)
	{
		Troca(&(h->fila[1]), &(h->fila[i]));
		SacodeHeap(h, i - 1);
	}

	return 1;
}


int AlteraHeap(Heap *h, const char *nome, int prioridade)
{
	int i = 1;

	if (h == NULL)
		return -1;

	/*Procura o paciente na fila*/
	while (i <= h->tam && strcmp(h->fila[i].nome, nome) != 0) i++;

	if (i > h->tam) /*Paciente não encontrado ou fila vazia*/
		return 0;

	h->fila[i].prioridade = prioridade;
	Heapfy(h);
	return 1;
}


void SacodeHeap(Heap *h, int tam)
{
	int i = 2;
	
	while (i <= tam)
	{
		if (i < tam && h->fila[i+1].prioridade > h->fila[i].prioridade) i++; //Verificar lógica da condição!!!!!!!!!!!!!!!!!
		
		if (h->fila[i/2].prioridade >= h->fila[i].prioridade) break;
		
		Troca(&(h->fila[i]), &(h->fila[i/2]));
		
		i = i*2;
		/* Será? !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		if (v[i/2].prioridade < v[i].prioridade)
			Troca(v[i], v[i/2]);
		*/
	}
}


void *LiberaHeap(Heap *h)
{
	if (h == NULL)
		return NULL;

	free(h);
	return NULL;
}